import os
import telebot
import requests
import time
import threading
import schedule
from flask import Flask, request
import gspread
from google.oauth2.service_account import Credentials
from telebot import types
from openai import OpenAI
from datetime import datetime
from bs4 import BeautifulSoup

BOT_TOKEN = os.environ.get("TG_BOT_TOKEN")
WEBHOOK_URL = os.environ.get("WEBHOOK_URL")
NEWSAPI_KEY = os.environ.get("NEWSAPI_KEY")
CRYPTO_API_KEY = os.environ.get("CRYPTO_API_KEY")
GOOGLE_JSON = os.environ.get("GOOGLE_JSON", "sage-instrument.json")
SHEET_ID = os.environ.get("SHEET_ID")
SHEET_NAME = os.environ.get("SHEET_NAME", "–õ–∏—Å—Ç1")
OPENAI_API_KEY = os.environ.get("OPENAI_API_KEY")
NEWS_CHAT_ID = os.environ.get("NEWS_CHAT_ID")
ADMIN_CHAT_ID = os.environ.get("ADMIN_CHAT_ID")

bot = telebot.TeleBot(BOT_TOKEN, threaded=False)
app = Flask(__name__)
client = OpenAI(api_key=OPENAI_API_KEY)
pending_weather_requests = {}

@app.route('/webhook', methods=['POST'])
def webhook():
    if request.headers.get('content-type') == 'application/json':
        update = telebot.types.Update.de_json(request.get_data().decode("utf-8"))
        bot.process_new_updates([update])
        return '', 200
    return '', 403

@app.route("/")
def index():
    return "Bot is running!", 200

def set_webhook():
    bot.remove_webhook()
    time.sleep(1)
    bot.set_webhook(url=WEBHOOK_URL.rstrip("/") + "/webhook")

def get_gsheet():
    creds = Credentials.from_service_account_file(GOOGLE_JSON, scopes=['https://www.googleapis.com/auth/spreadsheets'])
    gc = gspread.authorize(creds)
    return gc.open_by_key(SHEET_ID).worksheet(SHEET_NAME)

def log_error_to_sheet(error_msg):
    try:
        sh = get_gsheet()
        sh.append_row([time.strftime("%Y-%m-%d %H:%M:%S"), "error", error_msg])
    except:
        pass

TOP_ASICS = []

def update_top_asics():
    try:
        url = "https://www.asicminervalue.com/miners/sha-256"
        r = requests.get(url, timeout=10)
        soup = BeautifulSoup(r.text, "html.parser")
        TOP_ASICS.clear()
        for row in soup.select("table tbody tr")[:5]:
            tds = row.find_all("td")
            model = tds[0].get_text(strip=True)
            hr = tds[1].get_text(strip=True)
            watt = tds[2].get_text(strip=True)
            profit = tds[3].get_text(strip=True)
            TOP_ASICS.append(f"{model} ‚Äî {hr}, {watt}, –¥–æ—Ö–æ–¥: {profit}/–¥–µ–Ω—å")
    except Exception as e:
        TOP_ASICS.clear()
        TOP_ASICS.append(f"[–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è ASIC: {e}]")

def schedule_asic_updates():
    schedule.every().day.at("03:00").do(update_top_asics)
    update_top_asics()

def ask_gpt(prompt):
    try:
        res = client.chat.completions.create(
            model="gpt-4o",
            messages=[{"role": "user", "content": prompt}]
        )
        return res.choices[0].message.content.strip()
    except Exception as e:
        return f"[GPT –æ—à–∏–±–∫–∞: {e}]"

def get_weather(city):
    try:
        url = f"https://wttr.in/{city}?format=j1"
        r = requests.get(url).json()
        current = r["current_condition"][0]
        temp = current["temp_C"]
        desc = current["weatherDesc"][0]["value"]
        humidity = current["humidity"]
        wind = current["windspeedKmph"]
        return (
            f"üåç –ì–æ—Ä–æ–¥: {city.title()}\n"
            f"üå° –¢–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞: {temp}¬∞C\n"
            f"‚òÅÔ∏è –ü–æ–≥–æ–¥–∞: {desc}\n"
            f"üíß –í–ª–∞–∂–Ω–æ—Å—Ç—å: {humidity}%\n"
            f"üí® –í–µ—Ç–µ—Ä: {wind} –∫–º/—á"
        )
    except Exception as e:
        return f"[–û—à–∏–±–∫–∞ –ø–æ–≥–æ–¥—ã: {e}]"

def get_currency_rate(from_symbol, to_symbol):
    try:
        url = f"https://api.exchangerate.host/latest?base={from_symbol.upper()}&symbols={to_symbol.upper()}"
        data = requests.get(url).json()
        rate = data['rates'][to_symbol.upper()]
        return f"üí± {from_symbol.upper()} ‚Üí {to_symbol.upper()} = {rate:.2f}"
    except Exception as e:
        return f"[–û—à–∏–±–∫–∞ –∫—É—Ä—Å–∞: {e}]"

def get_coin_price(coin_id='bitcoin'):
    try:
        data = requests.get(f"https://api.coingecko.com/api/v3/simple/price?ids={coin_id}&vs_currencies=usd").json()
        return float(data[coin_id]['usd'])
    except:
        return None

def get_crypto_news():
    try:
        r = requests.get(f"https://cryptopanic.com/api/v1/posts/?auth_token={CRYPTO_API_KEY}&currencies=BTC,ETH&public=true").json()
        filtered = r.get("results", [])[:3]
        items = []
        for item in filtered:
            title = item.get("title", "–ë–µ–∑ –∑–∞–≥–æ–ª–æ–≤–∫–∞")
            url = item.get("url", "")
            translated = ask_gpt(f"–ü–µ—Ä–µ–≤–µ–¥–∏ –∏ –∫—Ä–∞—Ç–∫–æ –ø–æ—è—Å–Ω–∏:\n{title}")
            items.append(f"üîπ {translated}\n{url}")
        return "\n\n".join(items) if items else "[–ù–µ—Ç —Å–≤–µ–∂–∏—Ö –Ω–æ–≤–æ—Å—Ç–µ–π]"
    except Exception as e:
        return f"[–û—à–∏–±–∫–∞ CryptoPanic: {e}]"

def is_mining_price_message(text):
    return any(x in text.lower() for x in ["th", "asics", "–≤ –Ω–∞–ª–∏—á–∏–∏", "–ø—Ä–æ–¥–∞–º", "–±—É", "–Ω–æ–≤—ã–µ", "usd", "$"])

def analyze_mining_prices(text):
    prompt = (
        "–≠—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ –∏–∑ Telegram-—á–∞—Ç–∞ —Å –ø—Ä–∞–π—Å–∞–º–∏ –Ω–∞ –º–∞–π–Ω–∏–Ω–≥-–æ–±–æ—Ä—É–¥–æ–≤–∞–Ω–∏–µ."
        " –ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É–π –∫–∞–∫ —Ç—Ä–µ–π–¥–µ—Ä: –µ—Å—Ç—å –ª–∏ –≤—ã–≥–æ–¥–Ω—ã–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è, –∞–∫—Ç—É–∞–ª—å–Ω—ã–µ —Ü–µ–Ω—ã, –µ—Å—Ç—å –ª–∏ –ø–æ–¥–æ–∑—Ä–∏—Ç–µ–ª—å–Ω–æ –¥–µ—à–µ–≤—ã–µ."
        " –û—Ç–≤–µ—Ç—å –∫—Ä–∞—Ç–∫–æ, –Ω–∞ —Ä—É—Å—Å–∫–æ–º, –±–µ–∑ —Ñ–æ—Ä–º–∞–ª—å–Ω–æ—Å—Ç–µ–π.\n\n–¢–µ–∫—Å—Ç:\n" + text
    )
    return ask_gpt(prompt)

@bot.message_handler(func=lambda msg: True)
def handle_all_messages(msg):
    user_id = msg.from_user.id
    text = msg.text.lower()

    if user_id in pending_weather_requests:
        response = get_weather(msg.text)
        del pending_weather_requests[user_id]
        bot.send_message(msg.chat.id, response)
        return

    if "–ø–æ–≥–æ–¥–∞" in text:
        pending_weather_requests[user_id] = True
        bot.send_message(msg.chat.id, "üå¶ –í –∫–∞–∫–æ–º –≥–æ—Ä–æ–¥–µ –≤–∞—Å –∏–Ω—Ç–µ—Ä–µ—Å—É–µ—Ç –ø–æ–≥–æ–¥–∞?")
        return

    if "–∫—É—Ä—Å btc" in text:
        price = get_coin_price("bitcoin")
        bot.send_message(msg.chat.id, f"üí∞ –ö—É—Ä—Å BTC: ${price}" if price else "–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∫—É—Ä—Å BTC")
        return

    if "–¥–æ–ª–ª–∞—Ä –∫ –µ–≤—Ä–æ" in text:
        bot.send_message(msg.chat.id, get_currency_rate("usd", "eur"))
        return

    if "tiktok.com" in text:
        bot.send_message(msg.chat.id, "‚ö†Ô∏è –ë–æ—Ç –Ω–µ –º–æ–∂–µ—Ç –ø—Ä–æ—Å–º–∞—Ç—Ä–∏–≤–∞—Ç—å TikTok. –û–ø–∏—à–∏—Ç–µ —Å—É—Ç—å ‚Äî –ø–æ–º–æ–≥—É!")
        return

    if is_mining_price_message(text):
        feedback = analyze_mining_prices(msg.text)
        bot.send_message(msg.chat.id, feedback)
        return

    if any(k in text for k in ["asic", "–º–æ–¥–µ–ª—å", "—Ä–æ–∑–µ—Ç–∫–∞", "–∫–≤—Ç", "–≤—ã–≥–æ–¥–Ω–æ", "–¥–æ—Ö–æ–¥–Ω–æ—Å—Ç—å"]):
        models = "\n".join(TOP_ASICS)
        prompt = (
            "–ù–∏–∂–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω –∞–∫—Ç—É–∞–ª—å–Ω—ã–π —Å–ø–∏—Å–æ–∫ ASIC SHA‚Äë256 –º–æ–¥–µ–ª–µ–π, –ø–æ–ª—É—á–µ–Ω–Ω—ã–π —Å —Å–∞–π—Ç–∞ asicminervalue.com,"
            " –æ–±–Ω–æ–≤–ª—ë–Ω–Ω—ã–π —Å–µ–≥–æ–¥–Ω—è. –ò—Å–ø–æ–ª—å–∑—É–π –∏—Å–∫–ª—é—á–∏—Ç–µ–ª—å–Ω–æ —ç—Ç–∏ –¥–∞–Ω–Ω—ã–µ.\n\n"
            f"{models}\n\n–¢–µ–ø–µ—Ä—å –æ—Ç–≤–µ—Ç—å –Ω–∞ –≤–æ–ø—Ä–æ—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:\n{msg.text}"
        )
    else:
        prompt = msg.text

    try:
        answer = ask_gpt(prompt)
        markup = types.InlineKeyboardMarkup()
        markup.add(types.InlineKeyboardButton("üí¨ –ü—Ä–∞–π—Å –æ—Ç –ø–∞—Ä—Ç–Ω—ë—Ä–∞", url="https://app.leadteh.ru/w/dTeKr"))
        bot.send_message(msg.chat.id, answer, reply_markup=markup)
    except Exception as e:
        bot.send_message(msg.chat.id, f"[GPT –æ—à–∏–±–∫–∞: {e}]")

def auto_send_news():
    try:
        news = get_crypto_news()
        markup = types.InlineKeyboardMarkup()
        markup.add(types.InlineKeyboardButton("üí¨ –ü–æ–ª—É—á–∏—Ç—å –ø—Ä–∞–π—Å –æ—Ç –ø–∞—Ä—Ç–Ω—ë—Ä–∞", url="https://app.leadteh.ru/w/dTeKr"))
        bot.send_message(NEWS_CHAT_ID, news, reply_markup=markup)
    except Exception as e:
        print(f"[–ê–≤—Ç–æ—Ä–∞—Å—Å—ã–ª–∫–∞]: {e}")

def auto_check_status():
    errors = []
    for key, name in [(BOT_TOKEN, "BOT_TOKEN"), (WEBHOOK_URL, "WEBHOOK_URL"),
                      (NEWSAPI_KEY, "NEWSAPI_KEY"), (SHEET_ID, "SHEET_ID"), (OPENAI_API_KEY, "OPENAI_API_KEY")]:
        if not key or "‚ö†Ô∏è" in str(key): errors.append(name)
    try: ask_gpt("–ü—Ä–æ–≤–µ—Ä–∫–∞ GPT")
    except Exception as e: errors.append(f"GPT: {e}")
    try: get_gsheet()
    except Exception as e: errors.append(f"Sheets: {e}")
    status = "‚úÖ –í—Å–µ —Ä–∞–±–æ—Ç–∞–µ—Ç" if not errors else "‚ö†Ô∏è –ü—Ä–æ–±–ª–µ–º—ã:\n" + "\n".join(errors)
    bot.send_message(ADMIN_CHAT_ID, status)

schedule.every(3).hours.do(auto_send_news)
schedule.every(3).hours.do(auto_check_status)
schedule_asic_updates()

def run_scheduler():
    while True:
        schedule.run_pending()
        time.sleep(1)

if __name__ == '__main__':
    set_webhook()
    threading.Thread(target=run_scheduler).start()
    app.run(host="0.0.0.0", port=int(os.environ.get('PORT', 10000)))
